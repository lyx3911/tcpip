# 网络编程学习笔记

作者：李盈萱

[TOC]

## 第1章 网络编程和套接字

### 套接字创建

#### linux

服务器端：

接受连接请求的套接字创建过程：

1. 使用socket函数创建套接字
2. 调用bind函数分配ip地址和端口号
3. 调用listen函数转为可接收请求状态
4. 调用accept函数受理连接请求

```c
int socket(int domain, int type, int protocol);
int bind(int sockfd, struct sockaddr *myaddr, socklen_t addrlen);
int listen(int sockfd, int backlog);
int accept(int sockfd, struct sockaddr* addr, socklen_t *addrlen);
```

客户端：

1. 调用socket函数和connect函数
2. 与服务器端共同运行以收发字符串数据

```c
int connect(int sockfd, struct sockaddr* serv_addr, socklen_t addrlen);
```

服务器端代码：`ch1/hello_server.cpp`

客户端代码：`ch1/hello_client.cpp`

运行时

```bash
./hserver 9190
./hclient 127.0.0.1 9190
```

#### windows

在使用vscode编译的时候要加上参数 `-lwsock32`

其余编译运行操作差不多，代码见_win



### linux文件操作

文件描述符——文件句柄

打开文件

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
int open(const char *path, int flag); //成功则返回描述符，失败返回-1
```

关闭文件

```c
#include <unistd.h>
int close(int fd); //fd 需要关闭的文件或套接字的文件描述符
```

注意：linux系统不区分文件与套接字

写数据（对文件和套接字在linux系统是一样的）

```C
#include <unistd.h>
ssize_t write(int fd, const void* buf, size_t nbytes);
```

(操作系统定义的数据类型一般会加_t后缀)

读取数据

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
//fd 文件描述符，buf接受数据的缓冲区地址， nbytes接受数据的最大字节数
```



## 第2章 套接字类型与协议设置

第一章中所用的socket()函数，参数有

- domain 套接字中使用的协议族（protocol Family）信息，常用PF_INET, PF_INET6（分别为IPv4和IPv6互联网协议族）

- type 套接字数据传输类型信息
  - 面向连接的套接字 SOCK_STREAM
    - 传输过程中数据不会消失
    - 按序传输数据
    - 传输的数据不存在数据边界（所以无所谓read调用多少次）
    
    即使读取不够快，缓冲区满了一般也不会出错，因为额传输端会停止传输，传错也会提供重传服务
    
    **可靠的、按序传递的、基于字节的面向连接的数据传输方式**
    
  - 面向消息的套接字 SOCK_DGRAM
    - 强调快速传输而非传输顺序
    - 传输的数据可能丢失也可能损毁
    - 传输的数据有数据边界
    - 限制每次传输的数据大小
    
    **不可靠的、不按序传递的、以数据高速传输为目的的套接字**
  
- protocol 计算机间通信中使用的协议信息

IPV4网络协议族面向连接的数据传输只有TCP，面向消息的只有UDP，目前最常用的协议族也是IPV4,所以下面是最常见的两种创建方式

```c++
int tcp_socket = socket(PF_INET,SOCK_STREAM,IPPROTO_TCP);
int udp_socket = socket(PF_INET,SOCK_DGRAM,IPPROTP_UDP);
```



## 第3章 地址族与数据序列

### 地址族

IP地址包括网络ID 和主机ID 。

如果想要接受多台计算机发来的数据，就需要相应个数的套接字，操作系统参考端口号把数据传给相应的套接字。

- 一个端口号不可以分配给多个套接字（但是如果TCP使用了这个端口号，其他TCP 套接字就不能使用这个端口号了，但是UDP 还是可以）
- 端口号由16位构成，0-65535,但是0-1023一般分配给特定的程序，自己写的程序需要找分配其他的。

### 地址信息表示

`struct sockaddr_in`中的成员：

- `sa_family_t sin_family;`地址族 
- `uint16_t sin_port;`16位的端口号
- `struct in_addr in_addr;`32位IP地址
- `char sin_zero[8];`不使用

然后通过bind函数进行绑定（注意类型转换）

```c++
bind(serv_sock,(struct sockaddr* )&serv_addr,sizeof(serv_addr));
```

### 网络字节序与地址变换

- 大端序：高位字节存放到低位地址
- 小端序：高位字节存放到低位地址

目前Intel和AMD都是小端序，为了保持数据传输不出错，约定网络字节序为大端序，在传输时都处理成大端序

#### 转换函数

- 主机字节序转换成网络字节序
  - `unsigned short htons(unsigned short);`
  - `unsigned long htonl(unsigned long);`
- 网络字节序转换成主机字节序
  - `unsigned short ntohs(unsigned short);`
  - `unsigned long ntohl(unsigned long);`

**除了向sockaddr_in结构体变量填充数据外，其他情况无需考虑字节序问题**

### 网络地址初始化与分配

有函数能帮我们将字符串形式的IP地址（点分十进制表示法表示）转换成32位整数型数据并返回。

```c++
#include <arpa/inet.h>
in_addr_t inet_addr(const char* string);
```

但是我们在转换的时候通常是因为需要将它填充到sockaddr_in的结构体中，所以下面的这个函数更方便，可以直接填充。

```c++
#include <arpa/inet.h>
int inet_aton(const char* string, struct in_addr *addr)
```

服务前端的ip地址通常用INADDR_ANY来分配，可以自动获取，不必自己输入，但是客户机端一般不这么做。





## 第4章 基于TCP的服务器端/客户端（1）

IP本身是面向消息的，不可靠的协议，IP层在每次传输数据的时候会帮我们选择路径，但是并不一致，发生数据丢失或错误或乱序都无法解决。

**TCP可以保证数据正确的原因：**

数据交换过程中可以确认对方收到数据，并重传丢失数据。

### TCP服务器端默认的函数调用顺序

1. `socket()`创建套接字
2. `bind()`分配套接字地址
3. `listen()`等待连接请求状态
4. `accept()`允许连接
5. `read()/write()`数据交换
6. `close()`断开连接

### TCP客户端默认函数调用顺序

1. `socket()`创建套接字
2. `connect()`请求连接
3. `read()/write()`数据交换
4. `close()`断开连接

### 迭代回声服务器端/客户端实例

见`/ch4`代码



## 小结 主要函数汇总

### linux

1. #### socket

   - 作用：创建套接字

   - 头文件`sys/socket.h`

     ```c++
     int socket(int domain, int type, int protocol);
     ```

   - 参数：

     - domain 套接字中使用的协议族信息，如PF_INET
     - type 套接字中数据传输类型信息，如SOCK_STREAM/SOCK_DGRAM
     - protocol 通信协议，如IPPROTO_TCP/IPPROTO_UDP

   - 成功时返回**文件描述符**，失败时返回-1

2. #### bind

   - 作用：向套接字分配网络地址（仅服务器端需要）

   - 头文件`sys/socket.h`

     ```c++
     int bind(int sockfd, struct sockaddr* myaddr, socklen_t addrlen);
     ```

   - 参数

     - sockfd 要分配地址信息的套接字文件描述符
     - myaddr 存有地址信息的结构体变量**地址值**
     - addrlen 第二个结构体变量的长度

   - 成功时返回0,失败返回-1

   - **常见网络地址初始化方法**

   ```c++
   struct sockaddr_in addr;
   char* serv_ip = "211.217.167.13"; //申明IP地址字符串
   char* serv_port = "9190"; //声明端口号
   memset(&addr, 0, sizeof(addr));
   addr.sin_family = AF_INET;
   addr.sin_addr.s_addr = inet_addr(serv_ip);
   addr.sin_port = htons(atoi(serv_port));
   ```

3. #### listen

   - 作用：进入等待连接请求状态（服务器端）

   - 头文件`sys/socket.h`

     ```c++
     int listen(int sock, int backlog);
     ```

   - 参数

     - sock 希望进入等待连接请求状态的套接字文件描述符
     - backlog 连接请求等待队列的长度，若为5,则最多允许5个连接请求进入队列

   - 成功返回0,失败返回-1

4. #### accept

   - 作用：受理客户端连接请求（服务器端）

   - 头文件`sys.socket.h`

     ```c++
     int accept(int sock, struct sockaddr* addr, socklen_t* addrlen);
     ```

   - 参数

     - sock 服务器套接字的文件描述符
     - addr 保存发起连接请求的客户端地址信息的变量地址
     - addrlen 第二个参数addr结构体的长度

   - 成功时返回创建的套接字的文件描述符，失败时返回-1

5. #### connect

   - 作用：请求连接（客户机端）

   - 头文件`sys/socket.h`

     ```c++
     int connect(int sock, struct sockaddr* servaddr, socklen_t addrlen);
     ```

   - 参数

     - sock 客户端套接字文件描述符
     - servaddr 目标服务器地址信息的变量地址值
     - addrlen 第二个参数的长度 

   - 成功返回0,不成功返回-1

6. #### write

   - 作用：数据交换

   - 头文件`unistd.h`

     ```c++
     ssize_t write(int fd, const void* buf, size_t nbytes);
     ```

   - 参数

     - fd 数据传输对象的文件描述符
     - buf 要传输的数据的缓冲地址
     - nbytes 要传输数据的字节数

   - 成功时返回写入的字节数，失败时返回-1

7. #### read

   - 作用：数据交换

   - 头文件`unistd.h`

     ```c++
     ssize_t read(int fd, const void* buf, size_t nbytes);
     ```

   - 参数

     - fd 数据接受对象的文件描述符
     - buf 要保存接受数据的缓冲地址
     - nbytes 要接收数据的最大字节数

   - 成功时返回接收的字节数，失败时返回-1

8. #### close

   - 作用：关闭套接字

   - 头文件`unistd.h`

     ```c++
     int close(int fd);
     ```

   - 参数

     - fd 要关闭的套接字的文件描述符

   - 成功关闭返回0,否则返回-1



## 第5章 基于TCP的服务器端/客户端（2）

前面所写的回声客户端并不完美，若write()一次可能要发送的内容过多，拆成了两个数据包，但是调用read时可能只收到一个（一个数据包已经到达缓冲区，另一个数据包还未到达的时候就调用了read函数），有一种办法是设定一定的时延，确保所有的数据包都到达缓冲区，再调用read函数，但是这个时延的时间很不好设置。更好的办法是设计合理的应用层协议。

以一个读取n个数字计算和为例

- 客户端发送n个数字
- 服务器端计算和，发回给客户端

应用层协议：

- 客户端先发送一个数字，代表一共要发送的数字个数，再发送待计算的数字
- 服务器端先读取一个数的长度，就知道消息队列的大小，可以读完所有消息

实现见代码。

### TCP原理

#### TCP套接字的I/O缓冲

write函数调用后，并非立即传输数据，read函数调用后，也非马上接受数据，write调用时，数据移至输出缓冲，read调用时，从输入缓冲读取数据。

TCP中有滑动窗口协议，会控制数据流，不用担心缓存溢出而丢失数据。

#### TCP与对方套接字的连接（三次握手）

- 套接字A：套接字B，你好，我又数据要传输给你，建立连接吧
- 套接字B：好的，我以准备就绪
- 套接字A：谢谢你受理请求

#### TCP与对方主机数据交换

ACK消息：SEQ号+传递字节数+1

#### TCP断开与套接字的连接（四次挥手）

- 套接字A：我希望断开连接
- 套接字B：好的，请稍候
- 套接字B：准备就绪，可以断开
- 套接字A：谢谢合作



## 第6章 基于UDP的服务器端/客户端

如果收发的数据量小且需要频繁连接的话，UDP比TCP更加高效，TCP比UDP慢通常因为以下两点：

- 收发数据前后进行的连接设置及清除过程
- 收发数据过程中为保证可靠性增加的流控制

### 基于UDP的服务器端和客户端

- UDP中的服务器端和客户端没有连接

  - 因此不需要TCP那样嗲用listen和accept函数

- UDP服务器端和客户端均只需要一个套接字

  - TCP中套接字是一对一的关系，如果要向10个客户端提供服务，除了守门的服务器套接字外，还需要10个服务器端套接字。但UDP中，不管是服务器端还是客户端，都只需要一个套接字。

- 基于UDP的数据I/O函数

  - 发送

    ```c++
    ssize_t sendto(int sock, void*buff, ssize_t nbytes, int flags, struct sockaddr *to, socklen_t addrlen);
    ```

  - 参数

    - sock 用于传输数据的UDP套接字文件描述符
    - buff 保存待传输数据的缓冲地址
    - nbytes 待传输数据长度
    - flags 可选项参数，一般写0
    - to 存有目标地址信息的sockaddr结构体变量的地址
    - addrlen 传递给参数to的地址值结构体变量长度
    - 成功返回传输的字节数，失败返回-1

  - 接收

    ```c++
    ssize recvfrom(int sock, void*buff,ssize_t nbytes, int flags,struct sockaddr *from, socklen_t addrlen);
    ```

  - 参数

    - sock 用于接受数据的UDP套接字文件描述符
    - buff 保存待接收数据的缓冲地址
    - nbytes 待接收数据长度
    - flags 可选项参数，一般写0
    - from 存有发送端地址信息的sockaddr结构体变量的地址
    - addrlen 传递给参数from的地址值结构体变量长度
    - 成功返回传输的字节数，失败返回-1

### 基于UDP的回声服务器端/客户端

UDP和TCP不同，不存在请求连接和受理的过程。

#### 客户端的套接字地址分配

如果调用sendto函数发现尚未分配地址信息，则在首次调用sendto函数时自动给相应套接字分配IP和端口

#### 数据传输存在边界

验证见代码bound_host1.cpp 和bound_host2.cpp

即客户端调用了sendto3次，发送了三条消息，即使在服务器端第一次调用recvfrom时，三条消息都到达了缓冲区，一次也只能读取一条

#### 已连接和未连接的UDP套接字

UDP无需注册目标IP和端口号，所以sendto的时候，要进行

- 向UDP套接字注册目标IP和端口号
- 传输数据
- 删除UDP套接字中注册的目标地址信息

因此可以重复利用同一UDP套接字向不同的目标传输信息

但是如果要与一个目标长时间通信，变成已连接套接字会提高效率，连接使用coonect()函数，虽然函数的用法和TCP一样，但是不意味着建立连接，而只是向UDP套接字注册目标IP和端口信息。注册了之后数据交换可以使用sendto，recvfrom或者write，read

见uecho_con_client.cpp





## 第7章 优雅地断开套接字连接

#### 半关闭的作用

想象一个场景，客户端向服务器端请求一个文件，发送“thank you”给服务器端，这时候服务器端只需要传输文件即可，但是客户端则不知道什么时候文件接收完了（read函数返回0有可能是还有数据没到达），如果一直调用read也不知道什么时候结束。所以需要服务器端半关闭套接字，服务器端关闭输出流的时候会告诉客户端数据传输完成。

#### 半关闭函数

```c++
#include <sys/socket.h>
int shutdown(int sock, int howto);
```

参数：

- sock 需要半关闭的套接字文件描述符
- howto 断开方式的信息
  - SHUT_RD 断开输入流
  - SHUT_WR 断开输出流
  - SHUT_RDWR 同时断开输入输出



## 第8章 域名及网络地址

知道一个域名的ip，可以用命令行查询

```shell
ping www.bing.com
```

用IP地址比域名发生变更的概率更高，所以在写网络应用的时候，用域名写会比较好

#### hostent结构体

- char* h_name 官方域名
- char ** h_aliases 多个域名（同一个IP 可以绑定多个域名）
- int h_addrtype
- int h_length
- char ** h_addr_list （IP，同一网站有可能分配多个IP给同一个域名）

#### 利用域名获取IP地址

```c++
#include <netdb.h>
struct hostent* gethostbyname(const char *hostname);
```

输入：域名， 失败的时候返回null指针

#### 利用IP地址获取域名

```c++
#include <netdb.h>
struct hostent* gethostbyaddr(const char*addr, socklen_t len, int family);
```

参数：

- addr 含有ip地址信息的in_addr结构体指针
- len，第一个参数传递的地址信息的字节数，IPV4时为4,IPV6时为16
- family 协议族，IPV4时为AF_INET，IPv6时为AF_INET6



## 第9章 套接字的多种可选项

#### 套接字信息的读取

```c++
#include <sys/socket.h>
int getsockopt(int sock, int level, int optname, void *opval, socklen_t *optlen);
```
参数
- sock 套接字文件描述符
- level 要查看的可选项协议层
- optname 要查看的可选项名
- optval 保存查看结果的缓冲地址值
- optlen sizeof(opval)的地址
成功返回0,失败返回-1

#### 套接字信息的设置
```c++
#include <sys/socket.h>
int setsockopt(int sock, int level, int optname, void *opval, socklen_t optlen);
```
参数同getsockopt函数

#### 常见套接字操作
下面列出的都是level为SO_SOCKET的

- SO_RCVBUF/SO_SNDBUF 输入输出缓冲区的大小
- SO_REUSEADDR wait time有关参数(当服务器端被强制关闭并重启时，参考四次挥手原理和代码中的注释)



## 第10章 多进程服务器端

网络程序中数据通信的时间比CPU运算时间占比更大，因此向多个客户端提供服务是一种有效利用CPU的方式，主要有以下方法：

- 多进程服务器（通过创建多个进程提供服务）
- 多路复用服务器（通过捆绑并统一管理I/O对象提供服务）
- 多线程服务器（通过生成与客户端等量的线程提供服务）

### 进程

进程是程序流的基本单位

CPU中核的个数与可同时运行的进程数相同，如果进程数超过核数，进程将分时使用CPU资源，但是CPU运行的很快，会感到所有进程同时运行

创建进程：

```c++
#include <unistd.h>
pid_t fork();
```

成功时返回进程ID，失败时返回-1

**fork函数并非完全根据不同的程序创建进程，而是复制正在运行的、调用fork函数的进程，另外两个进程都将执行fork函数调用后的语句**，所以一般用if else语句配合进程id来区分父进程和子进程，然后执行不同的操作

- 父进程：fork函数返回子进程ID
- 子进程：fork函数返回0

**调用fork函数后，父子进程拥有完全独立的内存结构**

### 僵尸进程

注意区分进程终止和进程销毁

进程终止：

- 传递参数并调用exit()
- main函数中执行return函数并返回

**子进程终止时返回的值都会传递给操作系统，而操作系统不会销毁子进程，直到把这些值传递给产生该子进程的父进程**操作系统不会主动把值交给父进程，除非父进程调用。

### 销毁僵尸进程

- wait函数（会阻塞）

  ```c++
  #include <sys/wait.h>
  pid_t wait(int *statloc);
  ```

  返回值（statloc）需要用下列宏进行分离

  - WIFEXITED 子进程正常终止时返回true
  - WEXITSTATUS 返回子进程的返回值

- waitpid函数（不会阻塞）

  ```c++
  #include <sys/wait.h>
  pid_t waitpid(pid_t pid, int* statloc, int options);
  ```

  参数：

  - pid 等待终止的目标子进程ID，如果为-1,和wait一样可以等待任何子进程的终止
  - statloc和wait一样
  - options，一般填WNOHANG

  ### 信号处理
  - **signal函数**
	```c++
	#include <signal.h>
	void(*signal(int signo, void(*func)(int)))(int);
	```
	- 函数名 signal
	
	- 参数：
		- int signo
			- SIGALARM 已到通过调用alarm函数的时间
			- SIGINT 输入CTRL+C
			- SIGCHLD 子进程终止
  	- void(*func)(int)
  	
	- **sigaction函数**
		
	```c++
	#include <signal.h>
		int sigaction(int signo, const struct sigaction*act, struct sigaction*oldact);
		```
		
		参数：
		
		- signo和signal函数一样
		
		- act 对应第一个参数的信号处理函数
		
		- oldact 通过次参数获取之前注册的信号处理函数指针
		
		  ```c++
		  struct sigaction
		  {
		      void (*sa_handler)(int); //信号处理函数
		      sigset_t sa_mask; //sigemptyset(&act.mask)设为0
		      int sa_flags; //设为0
		  }
		  ```
		
		  

#### 例子
利用信号处理消灭僵尸进程

### 例子

  - 多进程服务器
  - 多进程实现客户端的I/O分离
